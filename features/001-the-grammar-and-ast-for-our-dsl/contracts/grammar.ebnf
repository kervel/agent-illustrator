(* Agent Illustrator DSL Grammar - EBNF Notation *)
(* Version: 3.1.0 *)
(* Design Goal: Minimal tokens for AI agent efficiency *)
(* Last Updated: 2026-01-24 *)

(* ============================================ *)
(* DOCUMENT STRUCTURE                           *)
(* ============================================ *)

document = { statement } ;

statement = shape_decl
          | connection_decl
          | layout_decl
          | group_decl
          | constraint_decl
          | alignment_decl
          | template_decl
          | template_instance
          | export_decl
          | comment ;

(* ============================================ *)
(* TEMPLATES (Feature 005)                      *)
(* ============================================ *)

(* Templates define reusable components from three sources:
   1. Inline AIL blocks with optional parameters
   2. External AIL files
   3. External SVG files

   Order-independent: templates can be declared and used in any order.
   Forward references are allowed (declarative, not procedural).
*)

template_decl = inline_template | file_template ;

(* Inline template: template "name" (params) { body } *)
inline_template = "template" string_literal [ param_list ] block ;

(* File template: template "name" from "path" *)
file_template = "template" string_literal "from" string_literal ;

(* Parameter list for AIL templates (SVG templates have no parameters) *)
param_list = "(" param_def { "," param_def } [ "," ] ")" ;

param_def = identifier ":" modifier_value ;

(* Template instantiation: template_name "instance_name" [arguments] *)
(* Note: Looks like shape_decl; resolved by checking known template names *)
template_instance = identifier string_literal [ modifier_block ] ;

(* Export declaration: makes internal elements accessible *)
export_decl = "export" identifier { "," identifier } ;

(* Examples:
   // Inline template with parameters
   template "button" (label: "Click", color: blue) {
       rect bg [fill: color]
       text txt [content: label]
       row { bg txt }
       export bg
   }

   // File templates
   template "server" from "components/server.ail"
   template "person" from "icons/person.svg"

   // Instantiation
   button "submit" [label: "Submit", color: green]
   server "s1"
   person "alice"

   // Connections to exported elements
   connect cable -> router1.wan    // OK: wan exported
   // connect cable -> router1.internal  // ERROR: not exported
*)

(* ============================================ *)
(* SHAPE DECLARATIONS                           *)
(* ============================================ *)

shape_decl = shape_type [ string_literal ] [ identifier ] [ modifier_block ] ;

shape_type = "rect" | "circle" | "ellipse" | "line" | "polygon" | "text"
           | icon_type
           | path_decl ;

icon_type = "icon" string_literal ;

(* Note: text shape requires a string literal: text "Hello" my_label *)

(* ============================================ *)
(* PATH SHAPE DECLARATIONS (Feature 007)       *)
(* ============================================ *)

(* Path shapes allow defining custom polygons with straight and curved segments.
   Vertices can be explicitly declared or implicitly created via line_to/arc_to.
   Positions are relative to the shape's origin (top-left corner).

   Syntax: path "name"? identifier? [modifiers]? { body }
*)

path_decl = "path" [ string_literal ] [ identifier ] [ modifier_block ] path_block ;

path_block = "{" { path_command } "}" ;

path_command = vertex_decl
             | line_to_decl
             | arc_to_decl
             | close_decl ;

(* Vertex declaration: declares a named vertex, optionally with position *)
vertex_decl = "vertex" identifier [ position_block ] ;

(* Position block for vertices *)
position_block = "[" position_spec { "," position_spec } [ "," ] "]" ;

(* Position specification: supports both x/y and directional syntax *)
position_spec = ( "x" | "y" | "right" | "left" | "up" | "down" ) ":" number_value ;

(* Line segment: straight line to a target vertex *)
line_to_decl = "line_to" identifier [ position_block ] ;

(* Arc segment: curved line to a target vertex with arc parameters *)
arc_to_decl = "arc_to" identifier [ arc_modifier_block ] ;

(* Arc modifier block supports position specs plus arc-specific params *)
arc_modifier_block = "[" arc_modifier { "," arc_modifier } [ "," ] "]" ;

arc_modifier = position_spec
             | "radius" ":" number_value
             | "bulge" ":" number_value
             | "sweep" ":" sweep_direction ;

(* Sweep direction for arcs *)
sweep_direction = "clockwise" | "counterclockwise" | "cw" | "ccw" ;

(* Close the path back to the starting vertex *)
close_decl = "close" ;

(* Arc parameter modes:
   - radius: arc radius in pixels, with sweep direction
   - bulge: tangent of (arc_angle/4), negative = opposite direction
     bulge = 0.414 gives a quarter-circle arc
*)

(* ============================================ *)
(* CONNECTIONS                                  *)
(* ============================================ *)

connection_decl = identifier connection_op identifier [ modifier_block ] ;

connection_op = "->"    (* forward/directed *)
              | "<-"    (* backward *)
              | "<->"   (* bidirectional *)
              | "--" ;  (* undirected *)

(* ============================================ *)
(* LAYOUT CONTAINERS                            *)
(* ============================================ *)

layout_decl = layout_type [ identifier ] [ modifier_block ] block ;

layout_type = "row" | "col" | "grid" | "stack" ;

block = "{" { statement } "}" ;

(* ============================================ *)
(* SEMANTIC GROUPS                              *)
(* ============================================ *)

group_decl = "group" [ identifier ] [ modifier_block ] block ;

(* ============================================ *)
(* POSITION CONSTRAINTS                         *)
(* ============================================ *)

constraint_decl = "place" identifier [ position_relation identifier ] [ modifier_block ] ;

position_relation = "right-of" | "left-of" | "above" | "below" | "inside" ;

(* Examples:
   place a right-of b              (* relational positioning *)
   place a [x: 10, y: 20]          (* offset positioning *)
   place a right-of b [x: 10]      (* relational with offset *)

   When combined with alignment:
   align a.left = b.right
   place a [x: 10]                 (* a is 10px right of b's right edge *)
*)

(* ============================================ *)
(* ALIGNMENT DECLARATIONS                       *)
(* ============================================ *)

alignment_decl = "align" anchor "=" anchor { "=" anchor } ;

anchor = element_path "." edge ;

element_path = identifier { "." identifier } ;

edge = "left" | "right" | "top" | "bottom"
     | "horizontal_center" | "vertical_center" ;

(* Examples:
   align a.left = b.left
   align x.horizontal_center = y.horizontal_center = z.horizontal_center
*)

(* ============================================ *)
(* STYLE MODIFIERS                              *)
(* ============================================ *)

modifier_block = "[" modifier { "," modifier } [ "," ] "]" ;

modifier = modifier_key ":" modifier_value ;

modifier_key = "fill" | "stroke" | "stroke_width" | "opacity"
             | "width" | "height" | "size" | "gap"
             | "label" | "label_position" | "font_size"
             | "routing" | "role"
             | identifier ;  (* extensible *)

modifier_value = color_value
               | number_value
               | string_literal
               | identifier    (* for references and keywords *)
               | keyword ;

(* ============================================ *)
(* COLORS                                       *)
(* ============================================ *)

color_value = hex_color | symbolic_color | color_name ;

hex_color = "#" hex_digits ;  (* #fff or #ffffff *)

(* Symbolic colors reference stylesheet palette *)
symbolic_color = color_category "-" level ;

color_category = "accent" | "foreground" | "background" | "text" | "status" ;

level = "1" | "2" | "3" | "light" | "dark"
      | "success" | "warning" | "error" ;

(* Examples: accent-1, text-2, foreground-light, status-error *)

color_name = "red" | "blue" | "green" | "yellow" | "black" | "white"
           | "gray" | "orange" | "purple" | "pink" | "cyan" ;

(* ============================================ *)
(* SPECIAL MODIFIER VALUES                      *)
(* ============================================ *)

(* Routing modes for connections *)
routing_value = "orthogonal" | "direct" ;

(* Label positions for connection labels *)
label_position_value = "center" | "start" | "end" | "left" | "right" ;

(* Role values for semantic element roles *)
role_value = "label" ;

(* ============================================ *)
(* NUMERIC VALUES                               *)
(* ============================================ *)

number_value = number [ unit ] ;

unit = "px" | "%" | "em" | "pt" ;

number = [ "-" ] digits [ "." digits ] ;

digits = digit { digit } ;

(* ============================================ *)
(* KEYWORDS                                     *)
(* ============================================ *)

keyword = "bold" | "italic" | "dashed" | "dotted" | "solid"
        | "thin" | "thick"
        | routing_value
        | label_position_value
        | role_value ;

(* ============================================ *)
(* COMMENTS                                     *)
(* ============================================ *)

comment = line_comment | block_comment ;

line_comment = "//" { any_char - newline } newline ;

block_comment = "/*" { any_char } "*/" ;

(* ============================================ *)
(* LEXICAL ELEMENTS                             *)
(* ============================================ *)

identifier = ( letter | "_" ) { letter | digit | "_" | "-" } ;

string_literal = '"' { string_char } '"' ;

string_char = any_char - '"' - "\"
            | "\" escape_char ;

escape_char = '"' | "\" | "n" | "t" | "r" ;

hex_digits = hex_digit { hex_digit } ;

letter = "a" | ... | "z" | "A" | ... | "Z" ;

digit = "0" | ... | "9" ;

hex_digit = digit | "a" | ... | "f" | "A" | ... | "F" ;

(* ============================================ *)
(* WHITESPACE (ignored except as separator)     *)
(* ============================================ *)

whitespace = " " | "\t" | "\n" | "\r" ;

(* Whitespace is insignificant and consumed between tokens *)

(* ============================================ *)
(* DEFAULTS                                     *)
(* ============================================ *)

(*
  Connection defaults:
  - routing: orthogonal
  - stroke: #333
  - stroke_width: 2

  Shape defaults:
  - No fill (transparent)
  - No stroke
*)

(* ============================================ *)
(* EXAMPLE VALID INPUTS                         *)
(* ============================================ *)

(*
  // Simple shapes
  rect server
  circle db [fill: accent-1]
  text "Hello World" greeting [font_size: 16, fill: text-1]

  // Connections
  server -> db [label: "query"]
  client <-> server
  a -- b [routing: direct, stroke: accent-1]

  // Connection with label reference
  text "My Label" lbl [font_size: 12]
  a -> b [label: lbl]

  // Layout
  row {
    rect a
    rect b
    rect c [fill: red]
  }

  // Groups with role-based labels
  group datacenter {
    text "Datacenter" [role: label, font_size: 18]
    row {
      rect rack1
      rect rack2
    }
  }

  // Alignment
  align a.left = b.left = c.left
  align x.horizontal_center = y.horizontal_center

  // Constraints
  place client right-of server

  // Icons
  icon "server" myserver [fill: gray]

  // Templates (Feature 005)
  template "labeled_box" (label: "Default", bg_color: white) {
      rect box [fill: bg_color]
      text lbl [content: label]
      row { box lbl }
      export box
  }

  template "server_icon" from "icons/server.svg"
  template "rack" from "components/rack.ail"

  labeled_box "input" [label: "Input"]
  labeled_box "output" [label: "Output", bg_color: accent-1]
  server_icon "s1"
  rack "r1"

  connect input -> output
  connect cable -> r1.port1   // port1 exported by rack template

  // Path shapes (Feature 007)

  // Simple triangle
  path "triangle" {
    vertex a
    line_to b [x: 50, y: 0]
    line_to c [x: 25, y: 40]
    close
  }

  // Arrow with curved back
  path "arrow" [fill: accent-1] {
    vertex tip [x: 100, y: 25]
    line_to top [x: 60, y: 0]
    arc_to back [x: 0, y: 25, bulge: 0.3]
    line_to bottom [x: 60, y: 50]
    close
  }

  // Rounded rectangle using arcs
  path "rounded_rect" [fill: background-1, stroke: foreground-1] {
    vertex top_left [x: 10, y: 0]
    arc_to top_right [x: 90, y: 0, radius: 10, sweep: clockwise]
    line_to bottom_right_arc [x: 100, y: 40]
    arc_to bottom_right [x: 90, y: 50, radius: 10, sweep: cw]
    line_to bottom_left_arc [x: 10, y: 50]
    arc_to bottom_left [x: 0, y: 40, radius: 10, sweep: cw]
    line_to top_left_arc [x: 0, y: 10]
    arc_to top_left [radius: 10, sweep: cw]
    close
  }

  // Path with directional positions
  path "shape" {
    vertex start
    line_to a [right: 50, down: 0]
    line_to b [right: 25, down: 40]
    close
  }

  // Path inside layout
  row {
    path "badge" [fill: green] {
      vertex a
      vertex b [x: 60, y: 0]
      vertex c [x: 60, y: 20]
      vertex d [x: 0, y: 20]
    }
    rect spacer [width: 10]
  }
*)
